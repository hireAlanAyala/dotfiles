name: Manage Linode VPS

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'provision'
        type: choice
        options:
          - provision
          - destroy
          - status
      instance_label:
        description: 'Instance label'
        required: false
        default: 'dev-server'
      instance_type:
        description: 'Instance type'
        required: false
        default: 'g6-standard-2'
      instance_region:
        description: 'Instance region'
        required: false
        default: 'us-east'
      dns_subdomain:
        description: 'DNS subdomain (optional, e.g. "myserver" for myserver.yourdomain.com)'
        required: false
        default: ''
      post_provision_script_url:
        description: 'URL to post-provision setup script (optional)'
        required: false
        default: ''

env:
  # User configuration
  USERNAME: developer
  SSH_PORT: 2222
  
  # Timeouts
  SSH_WAIT_TIMEOUT: 600  # 10 minutes
  DELETION_WAIT_TIMEOUT: 300  # 5 minutes
  
  # Package lists
  ESSENTIAL_PACKAGES: "sudo ufw git curl xz"
  SECURITY_PACKAGES: "fail2ban rkhunter lynis"
  # Dev packages now managed by Nix/Home Manager
  
  # System configuration
  SWAP_SIZE: "4G"  # Swap file size (empty to skip)
  ENABLE_BACKUPS: "false"  # Enable Linode backups ($2/month for Nanode)

jobs:
  manage-vps:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.action == 'destroy' && 'destroy-approval' || 'production' }}
    env:
      LINODE_CLI_TOKEN: ${{ secrets.LINODE_API_TOKEN }}
    
    steps:
      - uses: actions/checkout@v4
        with:
          path: .config
      
      - name: Setup
        run: |
          pip install linode-cli
          # Verify CLI is working
          linode-cli --version || exit 1
      
      - name: Generate SSH key if needed
        id: ssh
        run: |
          if [ "${{ github.event.inputs.action }}" = "provision" ]; then
            ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N "" -C "github-actions@arch-vps"
            echo "public_key=$(cat ~/.ssh/id_ed25519.pub)" >> $GITHUB_OUTPUT
          fi
      
      - name: Check for existing instance
        if: github.event.inputs.action == 'provision'
        id: check_existing
        run: |
          EXISTING=$(linode-cli linodes list \
            --label "${{ github.event.inputs.instance_label }}" \
            --text --no-headers --format "id,ipv4,status" || echo "")
          
          if [ -n "$EXISTING" ]; then
            echo "❌ Instance '${{ github.event.inputs.instance_label }}' already exists:"
            echo "$EXISTING"
            echo "exists=true" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "✅ No existing instance found with label '${{ github.event.inputs.instance_label }}'"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Provision VPS
        if: github.event.inputs.action == 'provision' && steps.check_existing.outputs.exists != 'true'
        id: provision
        run: |
          echo "=== Starting VPS provision at $(date) ==="
          
          # Create instance and get IP
          IP=$(linode-cli linodes create \
            --label "${{ github.event.inputs.instance_label }}" \
            --root_pass "${{ secrets.ROOT_PASSWORD }}" \
            --type "${{ github.event.inputs.instance_type }}" \
            --region "${{ github.event.inputs.instance_region }}" \
            --image "linode/arch" \
            --authorized_keys "${{ steps.ssh.outputs.public_key }}" \
            --text --no-headers --format "ipv4")
          
          echo "ip_address=$IP" >> $GITHUB_OUTPUT
          echo "✅ Created ${{ github.event.inputs.instance_label }} at $IP"
          echo "=== VPS created at $(date) ==="
      
      - name: Configure instance
        if: github.event.inputs.action == 'provision'
        run: |
          IP="${{ steps.provision.outputs.ip_address }}"
          echo "Configuring instance at IP: $IP"
          SSH="ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 root@$IP"
          
          # Wait for SSH (max timeout)
          echo "Waiting for SSH to be available at $IP..."
          timeout ${{ env.SSH_WAIT_TIMEOUT }} bash -c "until $SSH 'echo ready' 2>/dev/null; do echo -n '.'; sleep 10; done"
          echo "SSH is ready!"
          
          # Configure system
          $SSH << 'EOF'
            set -x  # Enable command tracing
            
            echo "=== Starting configuration at $(date) ==="
            
            # Enable parallel downloads for faster package installation
            sed -i 's/^#ParallelDownloads.*/ParallelDownloads = 5/' /etc/pacman.conf
            
            # Skip full system update, just sync package database
            echo "Syncing package database..."
            time pacman -Sy --noconfirm
            
            # Install essential packages first
            echo "Installing essential packages..."
            time pacman -S --noconfirm ${{ env.ESSENTIAL_PACKAGES }}
            
            # Create non-root user
            useradd -m -s /bin/bash -G wheel ${{ env.USERNAME }}
            echo "${{ env.USERNAME }}:${{ secrets.ROOT_PASSWORD }}" | chpasswd
            
            # Configure swap file for development workloads
            if [ -n "${{ env.SWAP_SIZE }}" ]; then
              echo "Creating ${{ env.SWAP_SIZE }} swap file..."
              fallocate -l ${{ env.SWAP_SIZE }} /swapfile || dd if=/dev/zero of=/swapfile bs=1M count=4096
              chmod 600 /swapfile
              mkswap /swapfile
              swapon /swapfile
              echo '/swapfile none swap sw 0 0' >> /etc/fstab
              
              # Adjust swappiness for development server
              echo 'vm.swappiness=10' >> /etc/sysctl.d/99-swappiness.conf
              sysctl -p /etc/sysctl.d/99-swappiness.conf
            fi
            
            # Configure sudo
            echo "%wheel ALL=(ALL) ALL" > /etc/sudoers.d/wheel
            
            # Copy SSH keys to new user
            mkdir -p /home/${{ env.USERNAME }}/.ssh
            cp /root/.ssh/authorized_keys /home/${{ env.USERNAME }}/.ssh/
            chown -R ${{ env.USERNAME }}:${{ env.USERNAME }} /home/${{ env.USERNAME }}/.ssh
            chmod 700 /home/${{ env.USERNAME }}/.ssh
            chmod 600 /home/${{ env.USERNAME }}/.ssh/authorized_keys
            
            # SSH Hardening
            echo "=== Configuring SSH ==="
            
            # Backup original config
            cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup
            
            # Test current SSH config
            sshd -t || echo "Initial SSH config has issues"
            
            # Change SSH port
            if grep -q "^#Port 22" /etc/ssh/sshd_config; then
              sed -i "s/^#Port 22/Port ${{ env.SSH_PORT }}/" /etc/ssh/sshd_config
            elif grep -q "^Port 22" /etc/ssh/sshd_config; then
              sed -i "s/^Port 22/Port ${{ env.SSH_PORT }}/" /etc/ssh/sshd_config
            else
              echo "Port ${{ env.SSH_PORT }}" >> /etc/ssh/sshd_config
            fi
            
            # Disable password authentication
            sed -i 's/^#*PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config
            
            # Disable root login
            sed -i 's/^#*PermitRootLogin.*/PermitRootLogin no/' /etc/ssh/sshd_config
            
            # Test the new configuration
            echo "Testing SSH configuration..."
            if ! sshd -t; then
              echo "SSH configuration test failed! Restoring backup..."
              cp /etc/ssh/sshd_config.backup /etc/ssh/sshd_config
              exit 1
            fi
            
            # Configure firewall BEFORE restarting SSH
            echo "=== Configuring firewall ==="
            ufw --force enable
            ufw default deny incoming
            ufw default allow outgoing  
            ufw allow 22/tcp comment 'SSH on default port (temporary)'
            ufw allow ${{ env.SSH_PORT }}/tcp comment 'SSH on custom port'
            
            # Restart SSH service
            echo "=== Restarting SSH service ==="
            # Try both service names (Arch might use either)
            if systemctl is-active sshd &>/dev/null; then
              systemctl restart sshd || {
                echo "SSH restart failed! Checking status..."
                systemctl status sshd
                journalctl -xeu sshd.service | tail -20
                # Don't exit, continue with setup
              }
            else
              systemctl restart ssh || {
                echo "SSH restart failed! Checking status..."
                systemctl status ssh
                journalctl -xeu ssh.service | tail -20
                # Don't exit, continue with setup
              }
            fi
            
            # Remove temporary port 22 access now that SSH is on 2222
            echo "=== Removing temporary port 22 access ==="
            ufw delete allow 22/tcp
            ufw status verbose
            
            # Security Hardening
            echo "=== Installing security packages ==="
            time pacman -S --noconfirm ${{ env.SECURITY_PACKAGES }}
            
            # Configure fail2ban for SSH protection
            echo "=== Configuring fail2ban ==="
            cat > /etc/fail2ban/jail.local << 'FAIL2BAN'
            [DEFAULT]
            bantime = 3600
            findtime = 600
            maxretry = 3
            destemail = root@localhost
            action = %(action_mwl)s
            
            [sshd]
            enabled = true
            port = ${{ env.SSH_PORT }}
            filter = sshd
            logpath = /var/log/auth.log
            maxretry = 3
            bantime = 3600
            FAIL2BAN
            
            systemctl enable fail2ban
            systemctl start fail2ban
            
            # Configure automatic security updates
            echo "=== Setting up automatic security updates ==="
            
            # Create systemd service for security updates
            cat > /etc/systemd/system/security-updates.service << 'SERVICE'
            [Unit]
            Description=Automatic Security Updates
            After=network.target
            
            [Service]
            Type=oneshot
            ExecStart=/usr/bin/pacman -Syu --noconfirm
            StandardOutput=journal
            StandardError=journal
            SERVICE
            
            # Create systemd timer for daily security updates
            cat > /etc/systemd/system/security-updates.timer << 'TIMER'
            [Unit]
            Description=Daily Security Updates
            Persistent=true
            
            [Timer]
            OnCalendar=daily
            RandomizedDelaySec=1h
            Persistent=true
            
            [Install]
            WantedBy=timers.target
            TIMER
            
            systemctl daemon-reload
            systemctl enable security-updates.timer
            systemctl start security-updates.timer
            
            # Additional hardening
            echo "=== Applying additional security hardening ==="
            
            # Kernel hardening via sysctl
            cat >> /etc/sysctl.d/99-security.conf << 'SYSCTL'
            # IP Spoofing protection
            net.ipv4.conf.all.rp_filter = 1
            net.ipv4.conf.default.rp_filter = 1
            
            # Ignore ICMP redirects
            net.ipv4.conf.all.accept_redirects = 0
            net.ipv6.conf.all.accept_redirects = 0
            
            # Ignore send redirects
            net.ipv4.conf.all.send_redirects = 0
            
            # Disable source packet routing
            net.ipv4.conf.all.accept_source_route = 0
            net.ipv6.conf.all.accept_source_route = 0
            
            # Log Martians
            net.ipv4.conf.all.log_martians = 1
            
            # Ignore ICMP ping requests
            net.ipv4.icmp_echo_ignore_broadcasts = 1
            
            # Ignore Directed pings
            net.ipv4.icmp_ignore_bogus_error_responses = 1
            
            # Enable TCP/IP SYN cookies
            net.ipv4.tcp_syncookies = 1
            net.ipv4.tcp_synack_retries = 2
            SYSCTL
            
            sysctl -p /etc/sysctl.d/99-security.conf
            
            # Set secure permissions on sensitive files
            chmod 600 /etc/ssh/sshd_config
            chmod 700 /root
            chmod 644 /etc/passwd
            chmod 644 /etc/group
            chmod 600 /etc/shadow
            chmod 600 /etc/gshadow
            
            # Show security status
            echo "=== Security configuration summary ==="
            fail2ban-client status
            systemctl list-timers security-updates.timer
            ufw status verbose
            
            echo "=== Configuration complete at $(date) ==="
          EOF
          
      - name: Install Nix and Home Manager
        if: github.event.inputs.action == 'provision'
        run: |
          IP="${{ steps.provision.outputs.ip_address }}"
          SSH_ROOT="ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 root@$IP"
          SSH_USER="ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 -p ${{ env.SSH_PORT }} ${{ env.USERNAME }}@$IP"
          
          echo "=== Preparing system for Nix installation ==="
          
          # Copy the .config directory to the VPS
          echo "Copying configuration files..."
          scp -r -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 -P ${{ env.SSH_PORT }} \
            .config ${{ env.USERNAME }}@$IP:~/
          
          # Install Nix and Home Manager as the developer user
          $SSH_USER << 'NIXINSTALL'
            set -euo pipefail
            
            echo "=== Backing up existing shell configs ==="
            [ -f ~/.profile ] && mv ~/.profile ~/.profile.backup
            [ -f ~/.bashrc ] && mv ~/.bashrc ~/.bashrc.backup
            
            echo "=== Installing Nix ==="
            # Install Nix multi-user
            sh <(curl -L https://nixos.org/nix/install) --daemon --yes
            
            # Source Nix environment
            if [ -e '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh' ]; then
              . '/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh'
            fi
            
            # Add Nix channels
            echo "=== Setting up Nix channels ==="
            nix-channel --add https://nixos.org/channels/nixos-unstable nixpkgs
            nix-channel --add https://github.com/nix-community/home-manager/archive/master.tar.gz home-manager
            nix-channel --update
            
            # Enable flakes and nix-command
            mkdir -p ~/.config/nix
            echo "experimental-features = nix-command flakes" > ~/.config/nix/nix.conf
            
            echo "=== Installing Home Manager ==="
            # Move any existing home-manager directory out of the way
            [ -d ~/home-manager ] && mv ~/home-manager ~/home-manager.backup
            
            # Install home-manager
            nix-shell '<home-manager>' -A install
            
            # Update flake inputs
            cd ~/.config/home-manager
            nix flake update
            
            # Switch to the home-manager configuration
            home-manager switch --flake .#${{ env.USERNAME }}
            
            echo "=== Configuration complete ==="
            
            # Show what's installed
            echo "PATH after home-manager: $PATH"
            
            # Source home-manager environment for immediate use
            . ~/.nix-profile/etc/profile.d/hm-session-vars.sh 2>/dev/null || true
            
            echo "=== Installed development tools ==="
            which git && git --version || echo "git not available"
            which go && go version || echo "go not available"  
            which node && node --version || echo "node not available"
            which python3 && python3 --version || echo "python3 not available"
            which docker && docker --version || echo "docker not available"
            
            echo "=== Home Manager packages ==="
            home-manager packages | head -20 || echo "Could not list packages"
          NIXINSTALL
          
      - name: Setup SSH keys and GPG (if secrets available)
        if: github.event.inputs.action == 'provision'
        continue-on-error: true
        run: |
          IP="${{ steps.provision.outputs.ip_address }}"
          SSH_USER="ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 -p ${{ env.SSH_PORT }} ${{ env.USERNAME }}@$IP"
          
          # Check if we have GPG key in secrets
          if [ -n "${{ secrets.GPG_PRIVATE_KEY }}" ]; then
            echo "=== Setting up GPG ==="
            $SSH_USER << 'GPGSETUP'
              # Import GPG key
              echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --import
              
              # Trust the key
              KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | awk '{print $2}' | cut -d'/' -f2)
              echo "${KEY_ID}:6:" | gpg --import-ownertrust
            GPGSETUP
          else
            echo "No GPG key found in secrets, skipping GPG setup"
          fi
          
          # Run SSH key setup if the script exists
          $SSH_USER << 'SSHSETUP'
            if [ -f ~/.ssh/setup_all_ssh_keys.sh ]; then
              echo "=== Setting up SSH keys ==="
              export GPG_TTY=$(tty)
              ~/.ssh/setup_all_ssh_keys.sh --all || echo "SSH key setup completed with some errors"
            else
              echo "No SSH setup script found, skipping"
            fi
          SSHSETUP
          
      - name: Run post-provision script
        if: github.event.inputs.action == 'provision' && github.event.inputs.post_provision_script_url != ''
        run: |
          IP="${{ steps.provision.outputs.ip_address }}"
          SSH="ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_ed25519 -p ${{ env.SSH_PORT }} ${{ env.USERNAME }}@$IP"
          
          echo "Running post-provision script from: ${{ github.event.inputs.post_provision_script_url }}"
          
          $SSH << 'EOF'
            set -e
            curl -fsSL "${{ github.event.inputs.post_provision_script_url }}" -o /tmp/post_provision.sh
            chmod +x /tmp/post_provision.sh
            /tmp/post_provision.sh
            rm -f /tmp/post_provision.sh
          EOF
      
      - name: Destroy VPS
        if: github.event.inputs.action == 'destroy'
        run: |
          # Get instance ID
          INSTANCE_ID=$(linode-cli linodes list \
            --label "${{ github.event.inputs.instance_label }}" \
            --text --no-headers --format "id" || echo "")
          
          if [ -z "$INSTANCE_ID" ]; then
            echo "❌ No instance found with label: ${{ github.event.inputs.instance_label }}"
            exit 0
          fi
          
          echo "🗑️ Initiating deletion of instance ID: $INSTANCE_ID"
          
          # Start deletion
          linode-cli linodes delete "$INSTANCE_ID"
          
          echo "⏳ Waiting for instance to be fully deleted..."
          
          # Initial wait to ensure deletion starts
          sleep 10
          
          # Poll until instance is gone
          SECONDS=10
          FOUND_DELETING=false
          
          while [ $SECONDS -lt ${{ env.DELETION_WAIT_TIMEOUT }} ]; do
            # Check instance status
            STATUS=$(linode-cli linodes view "$INSTANCE_ID" --format "status" --text --no-headers 2>&1 || echo "")
            
            if [[ "$STATUS" == *"not found"* ]] || [[ "$STATUS" == *"404"* ]] || [ -z "$STATUS" ]; then
              # Instance not found - but wait a bit more to ensure it's really gone
              echo "   Instance not found in API (elapsed: ${SECONDS}s)"
              
              # Double-check by listing all instances
              if ! linode-cli linodes list --text --no-headers | grep -q "$INSTANCE_ID"; then
                echo "   Verified: Instance ID $INSTANCE_ID no longer in instance list"
                
                # Wait additional time to ensure cleanup is complete
                echo "   Waiting 20 more seconds for complete cleanup..."
                sleep 20
                
                # Final check
                if ! linode-cli linodes list --text --no-headers | grep -q "$INSTANCE_ID"; then
                  echo "✅ Instance successfully deleted after $((SECONDS + 20)) seconds"
                  break
                fi
              fi
            elif [[ "$STATUS" == "deleting" ]] || [[ "$STATUS" == "shutting_down" ]]; then
              FOUND_DELETING=true
              echo "   Status: $STATUS (elapsed: ${SECONDS}s)"
            else
              echo "   Status: $STATUS (elapsed: ${SECONDS}s)"
            fi
            
            sleep 5
          done
          
          # Final verification with list command
          if linode-cli linodes list --text --no-headers | grep -q "$INSTANCE_ID"; then
            echo "⚠️ Warning: Instance still appears in list after 5 minutes"
            exit 1
          else
            echo "✅ Deletion confirmed - instance no longer in Linode account"
          fi
      
      - name: Show VPS Status
        if: github.event.inputs.action == 'status'
        run: |
          echo "## 📊 Linode VPS Status" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          linode-cli linodes list --text | tee -a $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          # Show detailed status in logs
          linode-cli linodes list
      
      - name: Output connection details
        if: github.event.inputs.action == 'provision'
        run: |
          echo "## 🚀 Development Server Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Type**: Linode 4GB (2 vCPU, 4GB RAM, 80GB SSD)" >> $GITHUB_STEP_SUMMARY
          echo "- **IP Address**: ${{ steps.provision.outputs.ip_address }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SSH Port**: ${{ env.SSH_PORT }} (custom)" >> $GITHUB_STEP_SUMMARY
          echo "- **Username**: ${{ env.USERNAME }} (with sudo + docker)" >> $GITHUB_STEP_SUMMARY
          echo "- **Root login**: Disabled" >> $GITHUB_STEP_SUMMARY
          echo "- **Package Manager**: Nix + Home Manager (declarative)" >> $GITHUB_STEP_SUMMARY
          echo "- **Development Tools**: Via home-manager config" >> $GITHUB_STEP_SUMMARY
          echo "- **Security**: Fail2ban, automatic updates, kernel hardening" >> $GITHUB_STEP_SUMMARY
          echo "- **Swap**: ${{ env.SWAP_SIZE }} configured" >> $GITHUB_STEP_SUMMARY
          echo "- **Monthly Cost**: ~\$24/month" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Connect using:" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "ssh -p ${{ env.SSH_PORT }} -i path/to/id_ed25519 ${{ env.USERNAME }}@${{ steps.provision.outputs.ip_address }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          # Create connection script
          cat > ~/.ssh/connect-${{ github.event.inputs.instance_label }}.sh << 'SCRIPT'
          #!/bin/bash
          ssh -p ${{ env.SSH_PORT }} -i "$(dirname "$0")/id_ed25519" ${{ env.USERNAME }}@${{ steps.provision.outputs.ip_address }} "$@"
          SCRIPT
          chmod +x ~/.ssh/connect-${{ github.event.inputs.instance_label }}.sh
          
          # Create README for the artifact
          cat > ~/.ssh/README.md << 'README'
          # SSH Connection Files for ${{ github.event.inputs.instance_label }}
          
          ## Quick Start
          ```bash
          # Make files executable and secure
          chmod 600 id_ed25519
          chmod +x connect-${{ github.event.inputs.instance_label }}.sh
          
          # Connect to your VPS
          ./connect-${{ github.event.inputs.instance_label }}.sh
          ```
          
          ## Manual Connection
          ```bash
          ssh -p ${{ env.SSH_PORT }} -i id_ed25519 ${{ env.USERNAME }}@${{ steps.provision.outputs.ip_address }}
          ```
          
          ## Connection Details
          - **Host**: ${{ steps.provision.outputs.ip_address }}
          - **Port**: ${{ env.SSH_PORT }} (custom SSH port)
          - **User**: ${{ env.USERNAME }} (has sudo access)
          - **Auth**: SSH key only (passwords disabled)
          
          ## Files in this Archive
          - `id_ed25519` - Private SSH key (KEEP SECURE!)
          - `id_ed25519.pub` - Public SSH key
          - `connect-${{ github.event.inputs.instance_label }}.sh` - Connection helper script
          - `README.md` - This file
          
          ## Security Notes
          - Keep the private key (`id_ed25519`) secure
          - Never share your private key
          - This is your ONLY way to access the VPS
          - Root login is disabled for security
          
          ## Security Features
          - **Fail2ban**: Protects against brute force attacks (3 attempts = 1 hour ban)
          - **Automatic Updates**: Daily security updates via systemd timer
          - **Kernel Hardening**: SYN cookies, IP spoofing protection, etc.
          - **UFW Firewall**: Only SSH port ${{ env.SSH_PORT }} allowed
          - **SSH Hardening**: Key-only auth, custom port, no root login
          
          ## Development Environment
          - **Nix Package Manager**: Reproducible, declarative package management
          - **Home Manager**: User environment managed via Git-tracked configuration
          - **Tools Included**: Go, Node.js, Python, Docker, CLI tools, and more
          - **Same as Local**: Identical environment to your local development setup
          
          ## First Login Tasks
          After connecting, you may want to:
          1. Set up GPG key (if using encrypted configs): Store key in GitHub secrets as GPG_PRIVATE_KEY
          2. Run SSH key setup: `~/.ssh/setup_all_ssh_keys.sh --all` (if needed)
          3. Update packages: `home-manager switch` (after config changes)
          
          ## If You Lose Access
          - Use Linode's Lish console (web-based terminal)
          - Or destroy and recreate the VPS
          
          ## Troubleshooting
          If connection fails:
          1. Check file permissions: `ls -la id_ed25519` (should be -rw-------)
          2. Verify IP is reachable: `ping ${{ steps.provision.outputs.ip_address }}`
          3. Check if using correct port: `-p ${{ env.SSH_PORT }}`
          README

      - name: Save SSH key as artifact
        if: github.event.inputs.action == 'provision'
        uses: actions/upload-artifact@v4
        with:
          name: ssh-keys-${{ github.event.inputs.instance_label }}
          path: |
            ~/.ssh/id_ed25519
            ~/.ssh/id_ed25519.pub
            ~/.ssh/connect-${{ github.event.inputs.instance_label }}.sh
            ~/.ssh/README.md
          retention-days: 30
